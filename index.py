from flask import Flask, render_template, request, jsonify, make_response
import os
import json
import data_process as dp
import re
app = Flask(__name__)

"""
    Honour Project: ANU Study Planner
    
    Author: Tianshu Wang
    uniID: u6342392
"""

""" 
    In this program, we receive data from the front end, and deliver it to the 
    back end.
"""

@app.route('/', methods=['POST','GET'])
def index(name=None):
    """
        This is the main page of our website.
    """
    return render_template('tree.html', name=name)

@app.route('/receiveData', methods=['POST','GET'])
def receiveData():
    """
        In this function, the server receive data from the front end, call the
        pre-processing program and after constructing the model, it returns the
        plan generated by our model back to the front end.
    """
    preference = request.get_json()
    program = preference.pop('program')
    enroll_yr = preference.pop('enroll_yr')
    enroll_sem = preference.pop('enroll_sem')
    spec = 0
    if 'spec' in preference:
        spec = int(preference['spec'])
        preference.pop('spec')

    program_link = 'https://programsandcourses.anu.edu.au/2019/program/'

    program_link = str(program_link) + str(program)
    # calculate which type of semester does the enrolled semester fall in
    # S1 in odd year, S2 in odd year, S1 in even year or S2 in even year 
    if int(enroll_yr)%2 == 1:
        if int(enroll_sem)%2 == 1:
            sem = 1
        else:
            sem = 2
    else:
        if int(enroll_sem)%2 == 1:
            sem = 3
        else:
            sem = 4
            
    # call the pre-processing program which put the model in file test1.mzn & test1.dzn
    scraper = dp.DegreeRuleScraper(str(program_link))
    orders = scraper.build_program_order_struct()
    orders.buildAModel(preference, sem, spec)
    
    # call MiniZinc to solve for the model
    cmd = 'minizinc --solver OSICBC test1.mzn test1.dzn > plan.txt'
    os.system(cmd)
    jsondata = readmyJson('plan')
       
    return jsonify(jsondata)

@app.route('/returnTheTable', methods=['POST','GET'])
def returnTheTable():
    """
        This function obtains data from the table in our GUI when updating it.
        After receiving the table, the MiniZinc model would be called and re-plan
        the courses.
    """
    preference = request.get_json()
    # Obtain the list containing replaced courses and the to-be-updated plan
    replaced = preference.pop('replaced')
    oldPlan = dict()
    readPlan = open('plan.txt')
    try:
        content = str(readPlan.read())
        courses = content.split(' ')[:-1]
        current = 0
        for i in courses:
            if re.match(r'^[0-9]', str(i)):
                current = int(i)
            else:
                oldPlan[i] = current
    finally:
        readPlan.close()
    
    # collect user information
    program = preference.pop('program')
    enroll_yr = preference.pop('enroll_yr')
    enroll_sem = preference.pop('enroll_sem')
    # user's specialisation 
    spec = 0
    if 'spec' in preference:
        spec = int(preference['spec'])
        preference.pop('spec')
    
    program_link = 'https://programsandcourses.anu.edu.au/2019/program/'

    program_link = str(program_link) + str(program)
    if int(enroll_yr)%2 == 1:
        if int(enroll_sem)%2 == 1:
            sem = 1
        else:
            sem = 2
    else:
        if int(enroll_sem)%2 == 1:
            sem = 3
        else:
            sem = 4
    # call the pre-processing program which put the model in file test1.mzn & test1.dzn
    scraper = dp.DegreeRuleScraper(str(program_link))
    orders = scraper.build_program_order_struct()
    orders.buildAModel(preference, sem, spec, oldPlan, replaced)
    
    # call MiniZinc to solve for the model
    cmd = 'minizinc --solver OSICBC test1.mzn test1.dzn > re-plan.txt'
    os.system(cmd)
    # read the new plan from the file containing it.
    jsondata = readmyJson('re-plan')
    return jsonify(jsondata)
    
def readmyJson(filename):
    """
        Reading files storing our generated plan, this function converts it into
        regular lists in Python.
    """
    file_object = open(str(filename)+'.txt')
    plan = dict()
    try:
        file_context = str(file_object.read())
        courses = file_context.split(' ')[:-1]
        plan1 = dict()
        plan2 = dict()
        plan3 = dict()
        plan4 = dict()
        plan1['semester'] = 'S1'
        plan2['semester'] = 'S2'
        plan3['semester'] = 'S3'
        plan4['semester'] = 'S4'
        timer = 0
        for i in courses:
            if len(i) == 1:
                # len(i) == 1 => this is not a course but a number denoting which 
                # semester the following courses should be taken (the format used in
                # those .txt file to separate courses in different semesters).
                timer = 1
                if int(i) == 1:
                    plan = plan1
                elif int(i) == 2:
                    plan = plan2
                elif int(i) == 3:
                    plan = plan3
                else:
                    plan = plan4
            else:
                # otherwise this element is a course.
                index = 'c'+str(timer)
                plan[index] = str(i)
                timer = timer + 1
        
        # Construct the final plan by adding course list for different semesters
        # into it.
        finalplan = list()
        finalplan.append(plan1)
        finalplan.append(plan2)
        finalplan.append(plan3)
        finalplan.append(plan4)
        
        jsondata = json.dumps(finalplan, sort_keys=True, indent=4, separators=(',', ': '))
        
    finally:
        file_object.close() 
    return jsondata